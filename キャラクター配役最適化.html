<!DOCTYPE html>
<html lang="ja"><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>キャラクター配役最適化アプリ</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e8f0f2; /* Light blue-grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            /* More pronounced, material-like shadow */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1), 0 6px 6px rgba(0, 0, 0, 0.08);
            width: 100%;
            max-width: 800px;
            border: 1px solid #e0e0e0;
        }
        h1 {
            color: #212121; /* Darker for prominence */
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 30px;
            text-align: center;
        }
        .player-input-section, .character-input-section, .preferences-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            /* Subtler section shadow */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #e9e9e9;
        }
        h2 {
            font-size: 1.75rem;
            font-weight: 600;
            color: #212121;
            margin-bottom: 15px;
        }
        h2.collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding-bottom: 10px;
            margin-bottom: 0;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #424242;
        }
        input[type="text"] {
            width: calc(100% - 20px);
            padding: 14px;
            margin-bottom: 15px;
            border: 1px solid #bdbdbd;
            border-radius: 8px;
            font-size: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        input[type="text"]:focus {
            border-color: #1e88e5; /* A more Material Design blue */
            box-shadow: 0 0 0 3px rgba(30, 136, 229, 0.2); /* Matching focus shadow */
            outline: none;
        }
        .button-group button,
        button.bg-blue-500 { /* Targeting specific buttons for consistent style */
            background-color: #1e88e5; /* Material Blue 600 */
            background-image: linear-gradient(135deg, #2196f3 0%, #1e88e5 100%); /* Subtle gradient */
            color: white;
            padding: 14px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15); /* More prominent button shadow */
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .button-group button i,
        button.bg-blue-500 i {
            margin-right: 0;
        }
        .button-group button:last-child {
            margin-right: 0;
        }
        .button-group button:hover,
        button.bg-blue-500:hover {
            background-color: #1976d2; /* Darker blue on hover */
            background-image: linear-gradient(135deg, #1e88e5 0%, #1976d2 100%);
            transform: translateY(-3px); /* Slightly more lift */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25); /* Stronger hover shadow */
        }
        .button-group button:active,
        button.bg-blue-500:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .button-group button.secondary {
            background-color: #616161;
            background-image: linear-gradient(135deg, #757575 0%, #616161 100%);
        }
        .button-group button.secondary:hover {
            background-color: #424242;
            background-image: linear-gradient(135deg, #616161 0%, #424242 100%);
        }
        .player-item, .character-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 18px;
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid #dcdcdc;
            cursor: grab;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* subtle shadow for items */
            background-color: #ffffff;
            color: #333;
            position: relative;
            overflow: hidden;
            padding-left: 26px; /* Adjusted padding for the stripe */
        }
        .player-item:hover, .character-item:hover {
            background-color: #f5f5f5; /* Light grey on hover */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Stronger hover shadow */
        }
        .player-item.dragging, .character-item.dragging {
            opacity: 0.7;
            border: 2px dashed #1e88e5; /* Match new primary color */
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        .player-item span, .character-item span {
            font-weight: 500;
        }
        .name-and-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-grow: 1;
            position: relative;
            z-index: 1;
        }

        .name-and-buttons .edit-input {
            flex-grow: 1;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
        }

        .player-item .edit-button,
        .character-item .edit-button {
            background: none;
            border: none;
            color: #1e88e5; /* Match new primary color */
            cursor: pointer;
            font-size: 1rem;
            padding: 4px;
            transition: color 0.2s ease;
        }

        .player-item .edit-button:hover,
        .character-item .edit-button:hover {
            color: #1565c0; /* Darker blue on hover */
        }

        .player-item button.delete-button,
        .character-item button.delete-button {
            background-color: #e53935; /* Material Red 600 */
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
        }
        .player-item button.delete-button i,
        .character-item button.delete-button i {
            margin: 0;
        }
        .player-item button.delete-button:hover,
        .character-item button.delete-button:hover {
            background-color: #c62828; /* Darker Red */
            transform: translateY(-1px);
        }

        /* Color stripe on the left edge */
        .color-stripe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 8px;
            border-top-left-radius: inherit;
            border-bottom-left-radius: inherit;
            pointer-events: none; /* Ensure it doesn't interfere with drag/drop */
        }

        .preferences-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #e9e9e9;
        }
        .player-preferences {
            margin-bottom: 15px;
            padding: 18px;
            background-color: #f5f5f5;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .player-preferences h3 {
            font-size: 1.35rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }
        #playerList {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 60px;
            border: 1px dashed #bdbdbd;
            padding: 12px;
            border-radius: 8px;
            background-color: #fdfdfd;
        }
        #playerList.dragging-over {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }

        .preference-list {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 60px;
            border: 1px dashed #bdbdbd;
            padding: 12px;
            border-radius: 8px;
            background-color: #fdfdfd;
        }
        .preference-list.dragging-over {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }

        .preference-item {
            padding: 10px 14px;
            border-radius: 6px;
            cursor: grab;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            background-color: #ffffff;
            color: #333;
            position: relative;
            overflow: hidden;
            padding-left: 22px; /* Adjusted padding for the smaller stripe */
        }
        .preference-item:hover {
            background-color: #f5f5f5; /* Light grey on hover */
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .preference-item .color-stripe {
            width: 6px; /* Slightly smaller stripe for preference items */
            border-top-left-radius: inherit;
            border-bottom-left-radius: inherit;
        }

        .results-section {
            padding: 20px;
            background-color: #e3f2fd;
            border-radius: 12px;
            border: 1px solid #bbdefb;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05); /* Consistent shadow */
        }
        .results-section h2 {
            color: #1976D2;
            font-size: 1.6rem;
            margin-bottom: 10px;
        }
        .result-item {
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 5px;
            padding: 4px 0;
            border-bottom: 1px dotted #e0e0e0;
        }
        .result-item:last-child {
            border-bottom: none;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22); /* Stronger message box shadow */
            z-index: 1000;
            border: 1px solid #cccccc;
            display: none;
        }
        .message-box p {
            margin-bottom: 25px;
            font-size: 1.2rem;
            color: #333;
            text-align: center;
            line-height: 1.5;
        }
        .message-box button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            display: block;
            margin: 0 auto;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .message-box button:hover {
            background-color: #45a049;
        }
        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding-top: 15px;
        }
        .collapsible-content.collapsed {
            max-height: 0;
            padding-top: 0;
            margin-bottom: 0;
        }
        .toggle-icon {
            transform: rotate(0deg);
            transition: transform 0.3s ease;
            font-size: 1.2rem;
            margin-left: 10px;
        }
        .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }
        .reset-button {
            background-color: #f44336;
            color: white;
            padding: 10px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
        }
        .reset-button:hover {
            background-color: #d32f2f;
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);
        }
        .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .section-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body class="bg-gray-100 p-4">
    <div class="container mx-auto">
        <h1>キャラクター配役最適化アプリ</h1>

        <div class="player-input-section">
            <h2 class="collapsible-header" onclick="toggleSection('player')">
                <div class="flex items-center">
                    プレイヤー設定 <span class="text-sm font-normal text-gray-500 ml-2">(リストの<strong class="font-bold">上</strong>にあるプレイヤーほど、配役の優先度が高くなります。ドラッグして順序を調整してください。)</span>
                </div>
                <div class="section-header-actions">
                    <!-- リセットボタンをクリックした際にイベントの伝播を停止 -->
                    <button onclick="event.stopPropagation(); resetPlayers();" class="reset-button" title="プレイヤー設定をリセット"><i class="fas fa-undo"></i></button>
                    <span id="playerToggleIcon" class="toggle-icon collapsed">▼</span>
                </div>
            </h2>
            <div id="playerSectionContent" class="collapsible-content collapsed">
                <div class="flex items-center space-x-2 mb-4">
                    <input type="text" id="playerName" placeholder="プレイヤー名を入力" class="flex-grow rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                    <button onclick="addPlayer()" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300" title="プレイヤーを追加"><i class="fas fa-plus"></i></button>
                    <button onclick="shufflePlayers()" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300" title="プレイヤーの優先度をランダムにシャッフル"><i class="fas fa-shuffle"></i></button>
                </div>
                <div id="playerList" class="space-y-2" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"></div>
            </div>
        </div>

        <div class="character-input-section">
            <h2 class="collapsible-header" onclick="toggleSection('character')">
                <div class="flex items-center">
                    キャラクター設定
                </div>
                <div class="section-header-actions">
                    <!-- リセットボタンをクリックした際にイベントの伝播を停止 -->
                    <button onclick="event.stopPropagation(); resetCharacters();" class="reset-button" title="キャラクター設定をリセット"><i class="fas fa-undo"></i></button>
                    <span id="characterToggleIcon" class="toggle-icon collapsed">▼</span>
                </div>
            </h2>
            <div id="characterSectionContent" class="collapsible-content collapsed">
                <div class="flex items-center space-x-2 mb-4">
                    <input type="text" id="characterName" placeholder="キャラクター名を入力" class="flex-grow rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                    <button onclick="addCharacter()" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300" title="キャラクターを追加"><i class="fas fa-plus"></i></button>
                </div>
                <!-- キャラクターリストのドラッグ＆ドロップイベントハンドラを追加 -->
                <div id="characterList" class="space-y-2" ondragover="handleCharListItemDragOver(event)" ondrop="handleCharListItemDrop(event)"></div>
            </div>
        </div>

        <div class="preferences-section">
            <h2 class="collapsible-header" onclick="toggleSection('preferences')">
                <div class="flex items-center">
                    配役希望の設定
                </div>
                <div class="section-header-actions">
                    <!-- リセットボタンをクリックした際にイベントの伝播を停止 -->
                    <button onclick="event.stopPropagation(); resetPlayerPreferences();" class="reset-button" title="配役希望をリセット"><i class="fas fa-undo"></i></button>
                    <span id="preferencesToggleIcon" class="toggle-icon collapsed">▼</span>
                </div>
            </h2>
            <div id="preferencesSectionContent" class="collapsible-content collapsed">
                <p class="text-gray-600 mb-4">各プレイヤーのキャラクター希望順位を、ドラッグ&amp;ドロップで<strong class="font-bold">左から優先度の高い順</strong>に並べ替えてください。</p>
                <div id="playerPreferencesContainer"></div>
            </div>
        </div>

        <div class="button-group flex justify-center mt-6">
            <button onclick="assignRolesAndRender()" class="secondary">配役を決定</button>
        </div>

        <div class="display-settings flex justify-center mt-4 mb-6 space-x-6">
            <label for="togglePreferenceRankDisplay" class="flex items-center text-sm font-normal text-gray-600 cursor-pointer">
                <input type="checkbox" id="togglePreferenceRankDisplay" class="mr-2 h-4 w-4 text-blue-600 rounded focus:ring-blue-500">
                希望順位を表示
            </label>
            <label for="toggleScoreDisplay" class="flex items-center text-sm font-normal text-gray-600 cursor-pointer">
                <input type="checkbox" id="toggleScoreDisplay" class="mr-2 h-4 w-4 text-blue-600 rounded focus:ring-blue-500">
                スコアを表示
            </label>
        </div>

        <div class="results-section">
            <h2>配役結果</h2>
            <div id="assignmentResults">
                <p class="text-gray-500">上記ボタンをクリックすると結果が表示されます。</p>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        // グローバル変数
        let players = [];
        // characters配列はオブジェクトの配列になります: [{ name: "Char1", bgColor: "hsl(...)", textColor: "black/white" }]
        let characters = []; 
        let playerPreferences = {}; // { player1: [charA, charB], player2: [charC, charA] }
        let displayPreferenceRank = true; // 希望順位表示のON/OFF
        let displayScore = true; // スコア表示のON/OFF
        let playerSectionCollapsed = false; // プレイヤー設定セクションの折り畳み状態
        let characterSectionCollapsed = false; // キャラクター設定セクションの折り畳み状態
        let preferencesSectionCollapsed = false; // 配役希望セクションの折り畳み状態
        let lastAssignments = null; // 最後に計算された配役結果を保存する変数

        // ドラッグ中のキャラクターアイテム（キャラクター設定リスト用）
        let draggedCharListItem = null;

        // ローカルストレージにデータを保存する関数
        function saveDataToLocalStorage() {
            localStorage.setItem('roleAssignmentPlayers', JSON.stringify(players));
            // characters配列はオブジェクトになったので、そのままJSON.stringify
            localStorage.setItem('roleAssignmentCharacters', JSON.stringify(characters));
            localStorage.setItem('roleAssignmentPreferences', JSON.stringify(playerPreferences));
            localStorage.setItem('roleAssignmentDisplayPreferenceRank', JSON.stringify(displayPreferenceRank)); // 希望順位表示設定を保存
            localStorage.setItem('roleAssignmentDisplayScore', JSON.stringify(displayScore)); // スコア表示設定を保存
            localStorage.setItem('roleAssignmentPlayerSectionCollapsed', JSON.stringify(playerSectionCollapsed)); // プレイヤーセクションの折り畳み状態を保存
            localStorage.setItem('roleAssignmentCharacterSectionCollapsed', JSON.stringify(characterSectionCollapsed)); // キャラクターセクションの折り畳み状態を保存
            localStorage.setItem('roleAssignmentPreferencesSectionCollapsed', JSON.stringify(preferencesSectionCollapsed)); // 配役希望セクションの折り畳み状態を保存
        }

        // ローカルストレージからデータをロードする関数
        function loadDataFromLocalStorage() {
            const storedPlayers = localStorage.getItem('roleAssignmentPlayers');
            const storedCharacters = localStorage.getItem('roleAssignmentCharacters');
            const storedPreferences = localStorage.getItem('roleAssignmentPreferences');
            const storedDisplayPreferenceRank = localStorage.getItem('roleAssignmentDisplayPreferenceRank');
            const storedDisplayScore = localStorage.getItem('roleAssignmentDisplayScore');
            const storedPlayerSectionCollapsed = localStorage.getItem('roleAssignmentPlayerSectionCollapsed');
            const storedCharacterSectionCollapsed = localStorage.getItem('roleAssignmentCharacterSectionCollapsed');
            const storedPreferencesSectionCollapsed = localStorage.getItem('roleAssignmentPreferencesSectionCollapsed');

            if (storedPlayers) {
                players = JSON.parse(storedPlayers);
            }
            if (storedCharacters) {
                const parsedCharacters = JSON.parse(storedCharacters);
                characters = parsedCharacters.map(char => {
                    if (typeof char === 'string') {
                        // Old format: just a string. Convert to new object format.
                        const newColor = generateCharacterColor();
                        return { name: char, bgColor: newColor.bgColor, textColor: newColor.textColor };
                    } else if (typeof char === 'object' && char !== null && typeof char.name === 'string') {
                        // New format, but check for missing color properties
                        if (!char.bgColor || !char.textColor) {
                            const newColor = generateCharacterColor();
                            char.bgColor = newColor.bgColor;
                            char.textColor = newColor.textColor;
                        }
                        return char; // Valid object, return as is
                    }
                    // Invalid or malformed entry, return null to be filtered out
                    return null;
                }).filter(char => char !== null); // Filter out any nulls (invalid entries)
            }
            if (storedPreferences) {
                playerPreferences = JSON.parse(storedPreferences);
            }
            if (storedDisplayPreferenceRank !== null) {
                displayPreferenceRank = JSON.parse(storedDisplayPreferenceRank);
            }
            if (storedDisplayScore !== null) {
                displayScore = JSON.parse(storedDisplayScore);
            }
            if (storedPlayerSectionCollapsed !== null) {
                playerSectionCollapsed = JSON.parse(storedPlayerSectionCollapsed);
            }
            if (storedCharacterSectionCollapsed !== null) {
                characterSectionCollapsed = JSON.parse(storedCharacterSectionCollapsed);
            }
            if (storedPreferencesSectionCollapsed !== null) {
                preferencesSectionCollapsed = JSON.parse(storedPreferencesSectionCollapsed);
            }
        }

        // メッセージボックスを表示する関数
        function showMessageBox(message) {
            document.getElementById('messageText').innerText = message;
            document.getElementById('messageBox').style.display = 'block';
        }

        // メッセージボックスを非表示にする関数
        function hideMessageBox() {
            document.getElementById('messageBox').style.display = 'none';
        }

        /**
         * HSLカラーを生成し、そのカラーに対する最適なテキストカラー（黒または白）を決定します。
         * @returns {{bgColor: string, textColor: string}} 生成された背景色と推奨されるテキストカラー
         */
        function generateCharacterColor() {
            const hue = Math.floor(Math.random() * 360); // 0-359のランダムな色相
            const saturation = 60 + Math.floor(Math.random() * 20); // 60-79%の彩度
            const lightness = 40 + Math.floor(Math.random() * 30); // 40-69%の明度

            const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // HSLをRGBに変換して輝度を計算し、コントラストの良いテキストカラーを決定
            const h = hue / 360;
            const s = saturation / 100;
            const l = lightness / 100;

            let r, g, b;

            if (s === 0) {
                r = g = b = l; // 無彩色の場合
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            const R = Math.round(r * 255);
            const G = Math.round(g * 255);
            const B = Math.round(b * 255);

            // 輝度を計算 (WCAG 2.0に基づく)
            const getLuminance = (r, g, b) => {
                const a = [r, g, b].map(v => {
                    v /= 255;
                    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2];
            };

            const luminance = getLuminance(R, G, B);
            // 輝度が閾値より高い場合は黒、低い場合は白のテキストを使用
            const textColor = luminance > 0.5 ? 'black' : 'white'; 

            return {
                bgColor: bgColor,
                textColor: textColor
            };
        }

        // プレイヤーを追加
        function addPlayer() {
            const playerNameInput = document.getElementById('playerName');
            const playerName = playerNameInput.value.trim();
            if (playerName && !players.includes(playerName)) {
                players.push(playerName);
                // 新しいプレイヤーの初期希望は、既存の全キャラクターをコピー
                playerPreferences[playerName] = characters.map(charObj => charObj.name); 
                saveDataToLocalStorage(); // データを保存
                renderPlayers();
                renderPlayerPreferences();
                playerNameInput.value = '';
            } else if (playerName && players.includes(playerName)) {
                showMessageBox('そのプレイヤーはすでに存在します。');
            } else {
                showMessageBox('プレイヤー名を入力してください。');
            }
        }

        // プレイヤーを削除
        function removePlayer(name) {
            players = players.filter(p => p !== name);
            delete playerPreferences[name];
            saveDataToLocalStorage(); // データを保存
            renderPlayers();
            renderPlayerPreferences();
        }

        // プレイヤーリストをレンダリング (ドラッグ＆ドロップ、編集対応)
        function renderPlayers() {
            const playerListDiv = document.getElementById('playerList');
            playerListDiv.innerHTML = '';
            players.forEach(player => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.draggable = true; // Make player items draggable
                playerItem.dataset.player = player; // Store player name in data attribute
                playerItem.ondragstart = handlePlayerDragStart;
                playerItem.ondragend = handlePlayerDragEnd;

                const nameDisplay = document.createElement('span');
                nameDisplay.textContent = player;
                nameDisplay.className = 'player-name-display';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = player;
                nameInput.className = 'edit-input hidden'; // Initially hidden
                nameInput.dataset.oldName = player; // Store original name for reference

                const editButton = document.createElement('button');
                editButton.className = 'edit-button';
                editButton.innerHTML = '<i class="fas fa-edit"></i>'; // Pencil icon
                editButton.title = '編集';

                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button';
                deleteButton.innerHTML = '<i class="fas fa-trash"></i>'; 
                deleteButton.title = '削除'; // ツールチップ
                deleteButton.onclick = () => removePlayer(player);

                const nameAndButtonsContainer = document.createElement('div');
                nameAndButtonsContainer.className = 'name-and-buttons';
                nameAndButtonsContainer.appendChild(nameDisplay);
                nameAndButtonsContainer.appendChild(nameInput);
                nameAndButtonsContainer.appendChild(editButton);
                
                playerItem.appendChild(nameAndButtonsContainer);
                playerItem.appendChild(deleteButton);

                playerListDiv.appendChild(playerItem);

                // Edit functionality
                editButton.onclick = () => {
                    if (nameInput.classList.contains('hidden')) {
                        // Switch to edit mode
                        nameDisplay.classList.add('hidden');
                        nameInput.classList.remove('hidden');
                        nameInput.focus();
                        nameInput.setSelectionRange(nameInput.value.length, nameInput.value.length); // カーソルを末尾に
                        editButton.innerHTML = '<i class="fas fa-check"></i>'; // Checkmark icon
                        editButton.title = '保存';
                    } else {
                        // Switch to display mode and save
                        savePlayerEdit(nameInput, player);
                        nameDisplay.classList.remove('hidden');
                        nameInput.classList.add('hidden');
                        editButton.innerHTML = '<i class="fas fa-edit"></i>'; // Pencil icon
                        editButton.title = '編集';
                    }
                };

                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        nameInput.blur(); // Trigger blur to save
                    }
                });

                nameInput.addEventListener('blur', () => {
                    savePlayerEdit(nameInput, player);
                    nameDisplay.classList.remove('hidden');
                    nameInput.classList.add('hidden');
                    editButton.innerHTML = '<i class="fas fa-edit"></i>';
                    editButton.title = '編集';
                });
            });
        }

        // プレイヤー名を保存する関数
        function savePlayerEdit(inputElement, oldName) {
            const newName = inputElement.value.trim();
            if (newName === oldName) {
                // 名前が変わっていない場合は何もしない
                return;
            }
            if (!newName) {
                showMessageBox('プレイヤー名は空にできません。');
                inputElement.value = oldName; // 元の名前に戻す
                return;
            }
            if (players.includes(newName)) {
                showMessageBox('そのプレイヤー名はすでに存在します。');
                inputElement.value = oldName; // 元の名前に戻す
                return;
            }

            // players配列の更新
            const playerIndex = players.indexOf(oldName);
            if (playerIndex !== -1) {
                players[playerIndex] = newName;
            }

            // playerPreferencesのキーを更新
            if (playerPreferences[oldName]) {
                playerPreferences[newName] = playerPreferences[oldName];
                delete playerPreferences[oldName];
            }
            
            saveDataToLocalStorage();
            renderPlayers(); // UIを再レンダリングして最新の状態を反映
            renderPlayerPreferences(); // 希望設定も更新
            // showMessageBox(`プレイヤー名が「${oldName}」から「${newName}」に変更されました。`); // Removed dialog
        }


        // プレイヤーの優先度をシャッフルする
        function shufflePlayers() {
            if (players.length === 0) {
                showMessageBox('シャッフルするプレイヤーがいません。');
                return;
            }
            // Fisher-Yates shuffle algorithm
            for (let i = players.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [players[i], players[j]] = [players[j], players[i]]; // Swap elements
            }
            saveDataToLocalStorage();
            renderPlayers();
            renderPlayerPreferences(); // プレイヤーの順序が変わったので希望設定も再レンダリング
            // showMessageBox('プレイヤーの優先順位をシャッフルしました。'); // Removed dialog
        }

        // プレイヤー設定をリセットする関数
        function resetPlayers() {
            players = [];
            playerPreferences = {}; // 希望もリセット
            saveDataToLocalStorage();
            renderPlayers();
            renderPlayerPreferences();
            showMessageBox('プレイヤー設定がリセットされました。');
        }

        // キャラクターを追加
        function addCharacter() {
            const characterNameInput = document.getElementById('characterName');
            const characterName = characterNameInput.value.trim();
            if (characterName && !characters.some(char => char.name === characterName)) { // Check if name exists
                const newColor = generateCharacterColor(); // 色を生成
                characters.push({ name: characterName, bgColor: newColor.bgColor, textColor: newColor.textColor });
                // 各プレイヤーの希望リストに新しいキャラクターを追加
                for (const player in playerPreferences) {
                    // 既にキャラクターが存在しない場合のみ追加
                    if (!playerPreferences[player].includes(characterName)) {
                        playerPreferences[player].push(characterName);
                    }
                }
                saveDataToLocalStorage(); // データを保存
                renderCharacters();
                renderPlayerPreferences();
                characterNameInput.value = '';
            } else if (characterName && characters.some(char => char.name === characterName)) {
                showMessageBox('そのキャラクターはすでに存在します。');
            } else {
                showMessageBox('キャラクター名を入力してください。');
            }
        }

        // キャラクターを削除
        function removeCharacter(name) {
            characters = characters.filter(c => c.name !== name); // オブジェクトでフィルタリング
            // 各プレイヤーの希望リストから削除されたキャラクターを削除
            for (const player in playerPreferences) {
                playerPreferences[player] = playerPreferences[player].filter(c => c !== name);
            }
            saveDataToLocalStorage(); // データを保存
            renderCharacters();
            renderPlayerPreferences();
        }

        // キャラクターリストをレンダリング (ドラッグ＆ドロップ、編集対応)
        function renderCharacters() {
            const characterListDiv = document.getElementById('characterList');
            characterListDiv.innerHTML = '';
            characters.forEach(charObj => { // キャラクターオブジェクトを反復処理
                const characterItem = document.createElement('div');
                characterItem.className = 'character-item';
                characterItem.draggable = true; // キャラクターアイテムをドラッグ可能にする
                characterItem.dataset.character = charObj.name; // キャラクター名をデータ属性に保存
                characterItem.ondragstart = handleCharListItemDragStart; // ドラッグ開始イベントハンドラ
                characterItem.ondragend = handleCharListItemDragEnd; // ドラッグ終了イベントハンドラ

                const colorStripe = document.createElement('div'); // Create color stripe
                colorStripe.className = 'color-stripe';
                colorStripe.style.backgroundColor = charObj.bgColor;
                characterItem.prepend(colorStripe); // Add stripe to the beginning

                const nameDisplay = document.createElement('span');
                nameDisplay.textContent = charObj.name;
                nameDisplay.className = 'character-name-display';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = charObj.name;
                nameInput.className = 'edit-input hidden'; // Initially hidden
                nameInput.dataset.oldName = charObj.name; // Store original name for reference

                const editButton = document.createElement('button');
                editButton.className = 'edit-button';
                editButton.innerHTML = '<i class="fas fa-edit"></i>'; // Pencil icon
                editButton.title = '編集';

                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button';
                deleteButton.innerHTML = '<i class="fas fa-trash"></i>'; 
                deleteButton.title = '削除'; // ツールチップ
                deleteButton.onclick = () => removeCharacter(charObj.name);

                const nameAndButtonsContainer = document.createElement('div');
                nameAndButtonsContainer.className = 'name-and-buttons';
                nameAndButtonsContainer.appendChild(nameDisplay);
                nameAndButtonsContainer.appendChild(nameInput);
                nameAndButtonsContainer.appendChild(editButton);

                characterItem.appendChild(nameAndButtonsContainer);
                characterItem.appendChild(deleteButton);
                
                characterListDiv.appendChild(characterItem);

                // Edit functionality
                editButton.onclick = () => {
                    if (nameInput.classList.contains('hidden')) {
                        // Switch to edit mode
                        nameDisplay.classList.add('hidden');
                        nameInput.classList.remove('hidden');
                        nameInput.focus();
                        nameInput.setSelectionRange(nameInput.value.length, nameInput.value.length); // カーソルを末尾に
                        editButton.innerHTML = '<i class="fas fa-check"></i>'; // Checkmark icon
                        editButton.title = '保存';
                    } else {
                        // Switch to display mode and save
                        saveCharacterEdit(nameInput, charObj.name);
                        nameDisplay.classList.remove('hidden');
                        nameInput.classList.add('hidden');
                        editButton.innerHTML = '<i class="fas fa-edit"></i>'; // Pencil icon
                        editButton.title = '編集';
                    }
                };

                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // Prevent form submission
                        nameInput.blur(); // Trigger blur to save
                    }
                });

                nameInput.addEventListener('blur', () => {
                    saveCharacterEdit(nameInput, charObj.name);
                    nameDisplay.classList.remove('hidden');
                    nameInput.classList.add('hidden');
                    editButton.innerHTML = '<i class="fas fa-edit"></i>';
                    editButton.title = '編集';
                });
            });
        }

        // キャラクター名を保存する関数
        function saveCharacterEdit(inputElement, oldName) {
            const newName = inputElement.value.trim();
            if (newName === oldName) {
                // 名前が変わっていない場合は何もしない
                return;
            }
            if (!newName) {
                showMessageBox('キャラクター名は空にできません。');
                inputElement.value = oldName; // 元の名前に戻す
                return;
            }
            if (characters.some(char => char.name === newName)) {
                showMessageBox('そのキャラクター名はすでに存在します。');
                inputElement.value = oldName; // 元の名前に戻す
                return;
            }

            // characters配列の更新
            const charObj = characters.find(c => c.name === oldName);
            if (charObj) {
                charObj.name = newName;
            }

            // playerPreferencesの値を更新
            for (const player in playerPreferences) {
                playerPreferences[player] = playerPreferences[player].map(charName => 
                    charName === oldName ? newName : charName
                );
            }
            
            saveDataToLocalStorage();
            renderCharacters(); // UIを再レンダリングして最新の状態を反映
            renderPlayerPreferences(); // 希望設定も更新
            // showMessageBox(`キャラクター名が「${oldName}」から「${newName}」に変更されました。`); // Removed dialog
        }


        // キャラクター設定をリセットする関数
        function resetCharacters() {
            characters = [];
            // 各プレイヤーの希望リストも空にする
            for (const player in playerPreferences) {
                playerPreferences[player] = [];
            }
            saveDataToLocalStorage();
            renderCharacters();
            renderPlayerPreferences();
            showMessageBox('キャラクター設定がリセットされました。');
        }

        // 各プレイヤーの配役希望セクションをレンダリング（ドラッグ＆ドロップ対応）
        function renderPlayerPreferences() {
            const container = document.getElementById('playerPreferencesContainer');
            container.innerHTML = '';

            players.forEach(player => {
                const playerPrefDiv = document.createElement('div');
                playerPrefDiv.className = 'player-preferences';
                playerPrefDiv.innerHTML = `
                    <h3>${player}の希望順位</h3>
                    <div id="prefList-${player}" class="preference-list" ondragover="handleCharacterDragOver(event)" ondrop="handleCharacterDrop(event, '${player}')">
                        <!-- Draggable characters will go here -->
                    </div>
                `;
                container.appendChild(playerPrefDiv);

                const prefList = document.getElementById(`prefList-${player}`);
                // プレイヤーの希望リストにないキャラクターを追加する
                const existingPreferences = playerPreferences[player] || [];
                
                // 現在の全キャラクターがプレイヤーの希望に含まれていることを確認し、順序を維持
                // charactersはオブジェクトの配列、existingPreferencesは名前の配列なので、マップして比較
                const currentCharacterNames = characters.map(charObj => charObj.name);
                const updatedPreferences = existingPreferences.filter(name => currentCharacterNames.includes(name));
                const missingCharacters = currentCharacterNames.filter(name => !updatedPreferences.includes(name));

                playerPreferences[player] = [...updatedPreferences, ...missingCharacters];

                playerPreferences[player].forEach(charName => {
                    const charObj = characters.find(c => c.name === charName); // キャラクターオブジェクトを見つけて色を取得
                    if (charObj) { // キャラクターオブジェクトが存在する場合のみレンダリング
                        const charItem = document.createElement('div');
                        charItem.className = 'preference-item';
                        charItem.draggable = true;
                        charItem.textContent = charObj.name;
                        charItem.dataset.character = charObj.name; // キャラクター名をデータ属性に保存
                        // charItem.style.backgroundColor = charObj.bgColor; // Removed
                        // charItem.style.color = charObj.textColor; // Removed

                        const colorStripe = document.createElement('div'); // Create color stripe
                        colorStripe.className = 'color-stripe';
                        colorStripe.style.backgroundColor = charObj.bgColor;
                        charItem.prepend(colorStripe); // Add stripe to the beginning

                        prefList.appendChild(charItem);
                    }
                });
            });
        }

        // 配役希望設定をリセットする関数
        function resetPlayerPreferences() {
            // 各プレイヤーの希望をキャラクターの初期順序に戻す
            const currentCharacterNames = characters.map(charObj => charObj.name);
            for (const player of players) {
                playerPreferences[player] = [...currentCharacterNames]; // 全キャラクターを初期順序で追加
            }
            saveDataToLocalStorage();
            renderPlayerPreferences();
            showMessageBox('配役希望の設定がリセットされました。');
        }

        // ======================== ドラッグ＆ドロップ処理 (キャラクター希望順位) ========================
        let draggedCharacterItem = null;
        let draggedCharacterSourcePlayer = null; // ドラッグ開始時のプレイヤー名を保持

        function handleCharacterDragStart(event) {
            draggedCharacterItem = event.target;
            draggedCharacterSourcePlayer = event.target.closest('.player-preferences').querySelector('h3').textContent.replace('の希望順位', '').trim(); // プレイヤー名を取得
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', draggedCharacterItem.dataset.character);
            setTimeout(() => {
                draggedCharacterItem.classList.add('dragging');
            }, 0);
        }

        function handleCharacterDragEnd() {
            if (draggedCharacterItem) {
                draggedCharacterItem.classList.remove('dragging');
            }
            draggedCharacterItem = null;
            draggedCharacterSourcePlayer = null; // リセット
        }

        function handleCharacterDragOver(event) {
            event.preventDefault(); // ドロップを許可
            const targetList = event.currentTarget;
            targetList.classList.add('dragging-over');

            const draggable = document.querySelector('.preference-item.dragging');

            // 別のプレイヤーの希望順位リストへのドロップを許可しない
            // ドラッグ中のアイテムの親要素とドロップ対象要素のIDを比較
            if (draggable && draggedCharacterSourcePlayer !== targetList.closest('.player-preferences').querySelector('h3').textContent.replace('の希望順位', '').trim()) {
                event.dataTransfer.dropEffect = 'none'; // ドロップ不可を示す
                return;
            } else {
                event.dataTransfer.dropEffect = 'move'; // ドロップ可を示す
            }

            const afterElement = getDragAfterElement(targetList, event.clientX, '.preference-item:not(.dragging)');
            
            // 同一リスト内での移動の場合のみDOMを操作して位置を更新
            if (draggable && draggable.parentElement === targetList) {
                if (afterElement == null) {
                    targetList.appendChild(draggable);
                } else {
                    targetList.insertBefore(draggable, afterElement);
                }
            }
        }

        function handleCharacterDrop(event, targetPlayer) {
            event.preventDefault();
            const targetList = event.currentTarget;
            targetList.classList.remove('dragging-over');

            if (!draggedCharacterItem) return;

            // 別のプレイヤーの希望順位リストへのドロップを許可しない
            if (draggedCharacterSourcePlayer !== targetPlayer) {
                // UIを再レンダリングして、ドラッグ開始前の状態に戻す
                renderPlayerPreferences();
                showMessageBox('キャラクターは、同じプレイヤーの希望順位リスト内でのみ移動できます。');
                return;
            }

            const droppedCharacter = draggedCharacterItem.dataset.character;

            // ターゲットリストのDOMから現在の順序を読み取り、playerPreferencesを更新
            const newOrderForTarget = Array.from(targetList.children)
                                          .filter(item => item.classList.contains('preference-item'))
                                          .map(item => item.dataset.character);

            playerPreferences[targetPlayer] = newOrderForTarget;
            saveDataToLocalStorage(); // データを保存

            // UIを再レンダリングしてデータと同期させる
            renderPlayerPreferences();

            // ドラッグ関連のグローバル変数をリセット
            draggedCharacterItem = null;
            draggedCharacterSourcePlayer = null;
        }


        // ======================== ドラッグ＆ドロップ処理 (プレイヤー) ========================
        let draggedPlayerItem = null;
        function handlePlayerDragStart(event) {
            draggedPlayerItem = event.target;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', draggedPlayerItem.dataset.player); // プレイヤー名をセット
            setTimeout(() => {
                draggedPlayerItem.classList.add('dragging');
            }, 0);
        }

        function handlePlayerDragEnd() {
            if (draggedPlayerItem) {
                draggedPlayerItem.classList.remove('dragging');
            }
            draggedPlayerItem = null;
        }

        function handlePlayerDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const targetList = event.currentTarget;
            targetList.classList.add('dragging-over');

            const afterElement = getDragAfterElement(targetList, event.clientY, '.player-item:not(.dragging)');
            const draggable = document.querySelector('.player-item.dragging');
            if (draggable) {
                if (afterElement == null) {
                    targetList.appendChild(draggable);
                } else {
                    targetList.insertBefore(draggable, afterElement);
                }
            }
        }

        function handlePlayerDrop(event) {
            event.preventDefault();
            const targetList = event.currentTarget;
            targetList.classList.remove('dragging-over');

            if (!draggedPlayerItem) return;

            // DOMの新しい順序に基づいてplayers配列を更新
            const newPlayerOrder = Array.from(targetList.children)
                                    .filter(item => item.classList.contains('player-item'))
                                    .map(item => item.dataset.player);

            players = newPlayerOrder; // グローバルなplayers配列を更新
            saveDataToLocalStorage(); // データを保存

            // UIを再レンダリング
            renderPlayers();
            renderPlayerPreferences(); // プレイヤーの表示順序が変わったので、希望設定セクションも更新

            draggedPlayerItem = null; // Reset
        }

        // ======================== ドラッグ＆ドロップ処理 (キャラクター設定リスト) ========================
        function handleCharListItemDragStart(event) {
            draggedCharListItem = event.target;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', draggedCharListItem.dataset.character);
            setTimeout(() => {
                draggedCharListItem.classList.add('dragging');
            }, 0);
        }

        function handleCharListItemDragEnd() {
            if (draggedCharListItem) {
                draggedCharListItem.classList.remove('dragging');
            }
            draggedCharListItem = null;
        }

        function handleCharListItemDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const targetList = event.currentTarget;
            targetList.classList.add('dragging-over');

            const afterElement = getDragAfterElement(targetList, event.clientY, '.character-item:not(.dragging)');
            const draggable = document.querySelector('.character-item.dragging'); // ドラッグ中のアイテムがキャラクターリストのものであることを確認
            if (draggable && draggable.parentElement === targetList) { // ドロップ対象が同じリスト内であることを確認
                if (afterElement == null) {
                    targetList.appendChild(draggable);
                } else {
                    targetList.insertBefore(draggable, afterElement);
                }
            }
        }

        function handleCharListItemDrop(event) {
            event.preventDefault();
            const targetList = event.currentTarget;
            targetList.classList.remove('dragging-over');

            if (!draggedCharListItem) return;

            // DOMの新しい順序に基づいてcharacters配列を更新
            const newCharacterOrderNames = Array.from(targetList.children)
                                              .filter(item => item.classList.contains('character-item'))
                                              .map(item => item.dataset.character);

            // characters配列を新しい順序に基づいて再構築
            const newCharactersArray = [];
            for (const name of newCharacterOrderNames) {
                const charObj = characters.find(c => c.name === name);
                if (charObj) {
                    newCharactersArray.push(charObj);
                }
            }
            characters = newCharactersArray; // グローバルなcharacters配列を更新

            saveDataToLocalStorage(); // データを保存

            // UIを再レンダリング
            renderCharacters();
            renderPlayerPreferences(); // キャラクターの順序が変わったので、希望設定セクションも更新

            draggedCharListItem = null; // Reset
        }


        // ドロップ位置に基づいて要素を挿入する場所を決定する汎用関数
        // isHorizontal: trueの場合、x座標に基づいて要素を決定。falseの場合、y座標。
        function getDragAfterElement(container, clientCoordinate, selector) {
            const draggableElements = [...container.querySelectorAll(selector)];

            // Determine if the container is primarily horizontal or vertical for drop positioning
            // .preference-list は横方向、その他 (playerList, characterList) は縦方向
            const isHorizontal = container.classList.contains('preference-list');

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                let offset;
                if (isHorizontal) {
                    offset = clientCoordinate - box.left - box.width / 2;
                } else {
                    offset = clientCoordinate - box.top - box.height / 2;
                }

                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // PythonコードのJavaScriptへの移植
        // itertools.permutations の代替 (簡易版)
        function permutations(arr) {
            if (arr.length === 0) return [[]];
            if (arr.length === 1) return [arr];
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const first = arr[i];
                const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
                const innerPerms = permutations(rest);
                for (let j = 0; j < innerPerms.length; j++) {
                    result.push([first, ...innerPerms[j]]);
                }
            }
            return result;
        }

        // 二次関数を定義
        function quadratic_function(x, X_NUM) {
            // 二次関数の係数を設定
            const a = 1 / (X_NUM**2);
            // 二次関数の式を定義
            const y = -a * (x - X_NUM) ** 2 + 1;
            return y;
        }

        // スコアを計算
        function calculate_score(roles, preferences) {
            let score = 0;
            const num_players = Object.keys(preferences).length;
            const player_list = players; // グローバルなplayers配列を使用

            for (const player in roles) {
                const role = roles[player];
                const characters = preferences[player]; // preferences[player] はキャラクター名の配列
                const num_characters = characters.length;
                const num_player = player_list.indexOf(player); // ここでplayers配列の順序を使用
                const num_character = characters.indexOf(role);

                if (num_character === -1) {
                    // キャラクターがプレイヤーの希望リストにない場合、低いスコアを与える
                    score += 0; // または非常に小さい負の数
                    continue;
                }

                score += (1 - quadratic_function(num_character, num_characters * 1.618)) *
                         (1 - quadratic_function(num_player, num_players * 1.618));
            }

            // 理論上の最大スコアを計算
            // 全てのプレイヤーが第一希望を割り当てられた場合の合計スコア
            let theoreticalMaxScoreSum = 0;
            for (let i = 0; i < num_players; i++) {
                // キャラクターの希望順位が0（第一希望）の場合、この部分は常に1となる
                // プレイヤーの優先度に応じた重み付けのみが残る
                theoreticalMaxScoreSum += (1 - quadratic_function(i, num_players * 1.618));
            }

            // theoreticalMaxScoreSum が0の場合（プレイヤーがいないなど）は、0を返す
            if (theoreticalMaxScoreSum === 0) {
                return 0;
            }

            // スコアを理論上の最大スコアで正規化
            return score / theoreticalMaxScoreSum;
        }

        // 配役を決定
        function assign_roles(preferences) {
            const currentPlayers = players; // 現在のプレイヤー順序を使用
            let roles = {}; // { player: assigned_role }
            let assigned_roles_initial = new Set(); // 初期配役で使われたキャラクター

            // 初期配役を決定（各プレイヤーの第一希望から順に空いているものを割り当てる）
            for (const player of currentPlayers) { // currentPlayersの順序で処理
                let assigned = false;
                for (const role of preferences[player]) {
                    if (!assigned_roles_initial.has(role)) {
                        roles[player] = role;
                        assigned_roles_initial.add(role);
                        assigned = true;
                        break;
                    }
                }
                // 希望キャラクターが全て埋まっている、または希望リストにないキャラクターを割り当てる場合
                if (!assigned) {
                    // まだ割り当てられていないキャラクターの中から選ぶ
                    // charactersはオブジェクトの配列なので、nameプロパティでフィルタリング
                    const unassignedChars = characters.filter(charObj => !assigned_roles_initial.has(charObj.name)).map(charObj => charObj.name);
                    if (unassignedChars.length > 0) {
                        roles[player] = unassignedChars[0]; // 最初の利用可能なキャラクターを割り当てる
                        assigned_roles_initial.add(unassignedChars[0]);
                    } else {
                        // 全てのキャラクターが割り当て済みの場合、希望リストの最後のキャラクターを割り当てる（望ましくないが、割り当てが必要な場合）
                        // ただし、希望リスト自体が空の場合もあるため、その場合は割り当て不能
                        if (preferences[player] && preferences[player].length > 0) {
                             roles[player] = preferences[player][preferences[player].length - 1];
                        } else {
                             // 希望リストも空で、割り当て可能なキャラクターもいない場合
                             roles[player] = '未割り当て'; 
                        }
                    }
                }
            }

            // 最も希望しないキャラクターが配役されているか確認
            const exist_unhappy = (currentRoles) => {
                return currentPlayers.some(player => { // currentPlayersの順序で処理
                    const playerPref = preferences[player];
                    if (!playerPref || playerPref.length === 0) return false;
                    return currentRoles[player] === playerPref[playerPref.length - 1];
                });
            };

            let unhappy_initial = exist_unhappy(roles);

            if (!unhappy_initial && Object.keys(roles).length === currentPlayers.length) {
                return roles;
            }

            // 配役の最適化を探索
            let best_roles = {};
            let best_score = -Infinity;

            // 利用可能なキャラクターのユニークなリストを取得 (名前のみ)
            const available_character_names = Array.from(new Set(characters.map(charObj => charObj.name)));

            if (currentPlayers.length === available_character_names.length) {
                 for (const perm of permutations(available_character_names)) { // available_character_namesの順列
                    const trial_roles = {};
                    for (let i = 0; i < currentPlayers.length; i++) {
                        trial_roles[currentPlayers[i]] = perm[i];
                    }

                    // 全てのプレイヤーにキャラクターが割り当てられていることを確認
                    if (Object.keys(trial_roles).length !== currentPlayers.length) {
                        continue;
                    }

                    if (exist_unhappy(trial_roles)) {
                        continue;
                    }

                    const trial_score = calculate_score(trial_roles, preferences);

                    if (trial_score > best_score) {
                        best_score = trial_score;
                        best_roles = { ...trial_roles };
                    }
                }
            } else {
                // プレイヤー数とキャラクター数が異なる場合（または一致していても、順列で全てを網羅できない複雑なケース）
                // バックトラッキングによる探索
                function findBestAssignment(playerIndex, currentRoles, assignedCharNames) {
                    // 全てのプレイヤーにキャラクターを割り当てたらスコアを評価
                    if (playerIndex === currentPlayers.length) {
                        // 全てのプレイヤーにキャラクターが割り当てられていることを確認
                        if (Object.keys(currentRoles).length === currentPlayers.length && !exist_unhappy(currentRoles)) {
                            const current_score = calculate_score(currentRoles, preferences);
                            if (current_score > best_score) {
                                best_score = current_score;
                                best_roles = { ...currentRoles };
                            }
                        }
                        return;
                    }

                    const currentPlayer = currentPlayers[playerIndex];
                    const playerPreferredCharNames = preferences[currentPlayer] || []; // 希望リストが空の場合を考慮

                    // このプレイヤーの希望リストをループ
                    for (const charName of playerPreferredCharNames) {
                        // そのキャラクターがまだ割り当てられていない場合
                        if (!assignedCharNames.has(charName)) {
                            currentRoles[currentPlayer] = charName; // キャラクターを割り当て
                            assignedCharNames.add(charName); // 割り当て済みに追加
                            
                            // 次のプレイヤーに移動
                            findBestAssignment(playerIndex + 1, currentRoles, assignedCharNames);
                            
                            // バックトラック：割り当てを解除して次の選択肢を試す
                            assignedCharNames.delete(charName);
                            delete currentRoles[currentPlayer];
                        }
                    }

                    // 希望リストのキャラクターが全て割り当てられていない、または割り当てられていないキャラクターが存在する場合
                    // プレイヤーの希望リスト以外の、まだ割り当てられていないキャラクターを割り当てる試行を行う
                    const remainingAvailableCharNames = characters.filter(charObj => !assignedCharNames.has(charObj.name)).map(charObj => charObj.name);
                    
                    if (Object.keys(currentRoles).length === playerIndex && remainingAvailableCharNames.length > 0) {
                        // 希望リストにないが、まだ割り当てられていないキャラクターの中から一つ割り当てる
                        const charNameToAssign = remainingAvailableCharNames[0]; // 最初の利用可能なキャラクターを選択
                        currentRoles[currentPlayer] = charNameToAssign;
                        assignedCharNames.add(charNameToAssign);
                        findBestAssignment(playerIndex + 1, currentRoles, assignedCharNames);
                        assignedCharNames.delete(charNameToAssign);
                        delete currentRoles[currentPlayer];
                    }
                    // ここで、playerIndexのプレイヤーに何も割り当てられないパスも考慮する必要があるかもしれません
                    // (例えば、全てのキャラクターが割り当て済みで、このプレイヤーに割り当てられるものがない場合など)
                    // しかし、現在のロジックでは、最終的に全てのプレイヤーに何らかのキャラクターが割り当てられるようにしています。
                }
                findBestAssignment(0, {}, new Set());
            }

            // 最適な配役が見つからなかった場合（全ての組み合わせが不満を生む場合など）、初期配役を返す
            // または、最善の配役が見つからなかった、かつ初期配役で全てのプレイヤーに割り当てられていない場合
            if (Object.keys(best_roles).length === 0) {
                let finalRoles = {};
                let usedCharacterNames = new Set();
                for (const player of currentPlayers) {
                    let assigned = false;
                    const playerPrefList = preferences[player] || [];

                    // プレイヤーの希望リストから優先的に割り当て
                    for (const charName of playerPrefList) {
                        if (!usedCharacterNames.has(charName)) {
                            finalRoles[player] = charName;
                            usedCharacterNames.add(charName);
                            assigned = true;
                            break;
                        }
                    }

                    if (!assigned) {
                        // 希望リストのキャラクターが全て割り当て済みの場合、まだ割り当てられていないキャラクターから選ぶ
                        const remainingCharNames = characters.filter(charObj => !usedCharacterNames.has(charObj.name)).map(charObj => charObj.name);
                        if (remainingCharNames.length > 0) {
                            finalRoles[player] = remainingCharNames[0];
                            usedCharacterNames.add(remainingCharNames[0]);
                        } else {
                            // 全てのキャラクターが割り当て済みの場合、プレイヤーの希望リストの最初のキャラクターを割り当てる
                            // （これはスコアが低くなる可能性が高いが、強制的に割り当てるため）
                            if (playerPrefList.length > 0) {
                                finalRoles[player] = playerPrefList[0];
                            } else {
                                // 希望リストも空で、割り当て可能なキャラクターもいない場合
                                finalRoles[player] = '未割り当て'; 
                            }
                        }
                    }
                }
                return finalRoles;
            }
            return best_roles;
        }

        // 配役結果を表示する関数
        function renderAssignmentResults(assignments) {
            const resultsDiv = document.getElementById('assignmentResults');
            resultsDiv.innerHTML = ''; // Clear existing results

            if (!assignments) {
                resultsDiv.innerHTML = '<p class="text-gray-500">上記ボタンをクリックすると結果が表示されます。</p>';
                return;
            }

            const preferencesForAlgorithm = {};
            for (const player of players) {
                preferencesForAlgorithm[player] = playerPreferences[player] || [];
            }

            for (const player in assignments) {
                const assignedCharacter = assignments[player];
                const playerPrefList = playerPreferences[player];
                
                let rankText = '';
                // displayPreferenceRankがtrueの場合のみ希望順位を表示
                if (displayPreferenceRank) { 
                    const preferenceRank = playerPrefList ? playerPrefList.indexOf(assignedCharacter) : -1;

                    if (preferenceRank !== -1) {
                        rankText = ` (希望順位: 第${preferenceRank + 1}位)`;
                    } else {
                        // 希望リストにない場合は、特別に表示
                        rankText = ` (希望リスト外)`;
                    }
                }
                
                const p = document.createElement('p');
                p.className = 'result-item';
                p.textContent = `${player}: ${assignedCharacter}${rankText}`;
                resultsDiv.appendChild(p);
            }

            // displayScoreがtrueの場合のみスコアを表示
            if (displayScore) {
                const finalScore = calculate_score(assignments, preferencesForAlgorithm);
                const scoreP = document.createElement('p');
                // クラス名を変更して、フォントサイズと色を調整し、より控えめにする
                scoreP.className = 'mt-4 text-sm text-gray-600'; 
                scoreP.textContent = `スコア: ${finalScore.toFixed(3)}`; // テキストを「スコア:」に変更
                resultsDiv.appendChild(scoreP);
            }
        }

        // 「配役を決定」ボタンが押されたときのハンドラ
        function assignRolesAndRender() {
            if (players.length === 0 || characters.length === 0) {
                showMessageBox('プレイヤーとキャラクターの両方を設定してください。');
                return;
            }

            if (players.length > characters.length) {
                showMessageBox('プレイヤーの数がキャラクターの数を超えています。すべてのプレイヤーに異なるキャラクターを割り当てられない可能性があります。');
            }

            const preferencesForAlgorithm = {};
            for (const player of players) {
                preferencesForAlgorithm[player] = playerPreferences[player] || [];
            }

            for (const player in preferencesForAlgorithm) {
                if (preferencesForAlgorithm[player].length === 0) {
                    showMessageBox(`プレイヤー「${player}」の希望キャラクターが設定されていません。キャラクターを追加するか、配役希望を設定してください。`);
                    return;
                }
            }

            // 配役を計算し、lastAssignmentsに保存
            lastAssignments = assign_roles(preferencesForAlgorithm);
            // 結果をレンダリング
            renderAssignmentResults(lastAssignments);
        }

        // セクションの表示/非表示を切り替える関数
        function toggleSection(sectionType) {
            const contentDiv = document.getElementById(`${sectionType}SectionContent`);
            const toggleIcon = document.getElementById(`${sectionType}ToggleIcon`);

            if (sectionType === 'player') {
                playerSectionCollapsed = !playerSectionCollapsed;
                if (playerSectionCollapsed) {
                    contentDiv.classList.add('collapsed');
                    toggleIcon.classList.add('collapsed');
                } else {
                    contentDiv.classList.remove('collapsed');
                    toggleIcon.classList.remove('collapsed');
                }
                saveDataToLocalStorage();
            } else if (sectionType === 'character') {
                characterSectionCollapsed = !characterSectionCollapsed;
                if (characterSectionCollapsed) {
                    contentDiv.classList.add('collapsed');
                    toggleIcon.classList.add('collapsed');
                } else {
                    contentDiv.classList.remove('collapsed');
                    toggleIcon.classList.remove('collapsed');
                }
                saveDataToLocalStorage();
            } else if (sectionType === 'preferences') { // 新しい配役希望セクション
                preferencesSectionCollapsed = !preferencesSectionCollapsed;
                if (preferencesSectionCollapsed) {
                    contentDiv.classList.add('collapsed');
                    toggleIcon.classList.add('collapsed');
                } else {
                    contentDiv.classList.remove('collapsed');
                    toggleIcon.classList.remove('collapsed');
                }
                saveDataToLocalStorage();
            }
        }

        // セクションの初期状態を適用する関数
        function applySectionState(sectionType, isCollapsed) {
            const contentDiv = document.getElementById(`${sectionType}SectionContent`);
            const toggleIcon = document.getElementById(`${sectionType}ToggleIcon`);
            if (isCollapsed) {
                contentDiv.classList.add('collapsed');
                toggleIcon.classList.add('collapsed');
            } else {
                contentDiv.classList.remove('collapsed');
                toggleIcon.classList.remove('collapsed');
            }
        }


        // 初期ロード時にローカルストレージからデータを読み込む
        document.addEventListener('DOMContentLoaded', () => {
            loadDataFromLocalStorage();
            renderPlayers();
            renderCharacters();
            renderPlayerPreferences();

            // 希望順位表示のチェックボックスのイベントリスナーを設定
            const togglePreferenceRankDisplayCheckbox = document.getElementById('togglePreferenceRankDisplay');
            if (togglePreferenceRankDisplayCheckbox) {
                togglePreferenceRankDisplayCheckbox.addEventListener('change', (event) => {
                    displayPreferenceRank = event.target.checked;
                    saveDataToLocalStorage(); // 設定変更を保存
                    if (lastAssignments) { // 既に配役結果がある場合のみ表示を更新
                        renderAssignmentResults(lastAssignments);
                    }
                });
                // グローバル変数を初期のチェックボックス状態と同期
                togglePreferenceRankDisplayCheckbox.checked = displayPreferenceRank;
            }

            // スコア表示のチェックボックスのイベントリスナーを設定
            const toggleScoreDisplayCheckbox = document.getElementById('toggleScoreDisplay');
            if (toggleScoreDisplayCheckbox) {
                toggleScoreDisplayCheckbox.addEventListener('change', (event) => {
                    displayScore = event.target.checked;
                    saveDataToLocalStorage(); // 設定変更を保存
                    if (lastAssignments) { // 既に配役結果がある場合のみ表示を更新
                        renderAssignmentResults(lastAssignments);
                    }
                });
                // グローバル変数を初期のチェックボックス状態と同期
                toggleScoreDisplayCheckbox.checked = displayScore;
            }

            // プレイヤー設定とキャラクター設定セクションの初期折り畳み状態を適用
            applySectionState('player', playerSectionCollapsed);
            applySectionState('character', characterSectionCollapsed);
            applySectionState('preferences', preferencesSectionCollapsed); // 配役希望セクションの初期状態を適用
        });
    </script>


</body></html>
