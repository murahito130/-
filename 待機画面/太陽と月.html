<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配信待機中...</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- M PLUS Rounded 1c フォントを読み込み -->
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap" rel="stylesheet">
    <!-- 源ノ角ゴシック JP Light (Noto Sans JP Light) フォントを読み込み -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300&display=swap" rel="stylesheet">
    <style>
        /* Overall style settings */
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            height: 100vh; /* Match viewport height */
            position: relative;
            font-family: 'M PLUS Rounded 1c', sans-serif; /* Default font settings */
            color: #ffffff; /* Default text color */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center; /* Ensures content block is centered within body */
        }

        /* Background gradient animation */
        .background-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Background gradient is controlled by JavaScript, so CSS transition is not needed */
            background: linear-gradient(to bottom, #000000, #0a0a20); /* Initial background like deep night */
            z-index: -1;
        }

        /* Container for sun and moon */
        .celestial-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Sun style */
        .sun {
            position: absolute;
            width: 100px; /* Make sun and moon roughly the same size */
            height: 100px;
            background: radial-gradient(circle, #FFD700, #FFA500); /* Sun's gradient */
            border-radius: 50%;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            /* Position and opacity are controlled by JavaScript, so CSS transition is not needed */
        }

        /* Moon style */
        .moon {
            position: absolute;
            width: 100px; /* Make sun and moon roughly the same size */
            height: 100px;
            background: radial-gradient(circle, #F0F8FF, #B0C4DE); /* Moon's gradient */
            border-radius: 50%;
            /* Adjusted box-shadow to give a glowing effect, similar to the sun */
            box-shadow: 0 0 40px rgba(240, 248, 255, 0.7), 0 0 60px rgba(176, 196, 222, 0.5);
            filter: grayscale(0.2); /* Apply slight grayscale to moon */
            /* Position and opacity are controlled by JavaScript, so CSS transition is not needed */
        }

        /* Star container */
        .star-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Disable click events */
            overflow: hidden; /* Hide stars overflowing the container */
            opacity: 0; /* Hidden initially */
            transition: opacity 2s ease-in-out; /* Fade in/out */
        }

        /* Twinkling star style */
        .star {
            position: absolute;
            background: #ffffff; /* Star color */
            border-radius: 50%; /* Make circular */
            opacity: 0; /* Transparent initially */
            animation: twinkle 4s infinite ease-in-out; /* Twinkle animation */
        }

        /* Shooting star style */
        .shooting-star {
            position: absolute;
            background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0)); /* Shooting star gradient */
            width: 5px; /* Shooting star width */
            height: 2px; /* Shooting star height */
            opacity: 0; /* Transparent initially */
            transform: rotate(45deg); /* Display diagonally */
            animation: shoot 8s infinite linear; /* Shooting star animation */
        }

        /* Content area style */
        .content {
            z-index: 10; /* Display above stars */
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
            padding: 40px 60px;
            border-radius: 20px; /* Rounded corners */
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3); /* Shadow */
            animation: fadeIn 2s forwards; /* Fade-in animation */
            text-align: center; /* Explicitly ensure text is centered within the content block */
            /* Added for vertical centering of content inside this block */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center content */
            align-items: center; /* Horizontally center content (already handled by text-align, but good for flexbox) */
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8); /* Text shadow */
        }

        p {
            font-size: 1.8em;
            margin-top: 0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.6); /* Text shadow */
        }

        /* Style for the waiting message */
        .waiting-message {
            font-family: 'Noto Sans JP Light', '源ノ角ゴシック JP Light', sans-serif;
        }

        /* Keyframes for twinkle animation */
        @keyframes twinkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }

        /* Keyframes for shooting star animation */
        @keyframes shoot {
            0% {
                transform: translate(-100vw, -100vh) rotate(45deg); /* Start from top-left */
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            20% {
                transform: translate(100vw, 100vh) rotate(45deg); /* Move to bottom-right */
                opacity: 0;
            }
            100% {
                opacity: 0; /* Transparent for the rest of the time */
            }
        }

        /* Keyframes for fade-in animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Media queries for responsive design */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5em;
            }
            p {
                font-size: 1.2em;
            }
            .content {
                padding: 30px 40px;
            }
            .sun, .moon {
                width: 80px;
                height: 80px;
            }
        }

        /* Weather styles */
        .cloud-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; /* Between background and content */
            /* opacity: 0; Hidden by default - managed by JS now */
            pointer-events: none;
            overflow: hidden; /* Clouds will be clipped by this container */
            /* transition: opacity 2s ease-in-out; - managed by JS now */
        }

        /* New: Canvas for dynamic clouds */
        #cloudCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .rain-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6; /* Above clouds */
            opacity: 0; /* Hidden by default - managed by JS now */
            pointer-events: none;
            overflow: hidden; /* Raindrops stay within the container */
            transition: opacity 2s ease-in-out; /* Add smooth transition for opacity (changed from 1s to 2s) */
        }

        /* New styles for individual raindrops */
        .raindrop {
            position: absolute;
            /* どの時間帯でも見えやすくなるように、色と不透明度を調整しました */
            background: rgba(150, 180, 255, 0.8); /* わずかに暗く、不透明度を上げた青色の雨粒 */
            width: 2px;
            animation: raindrop-fall linear infinite;
            opacity: 0; /* Hidden initially */
        }

        @keyframes raindrop-fall {
            0% {
                transform: translateY(-10vh) translateX(0); /* Start from top of screen */
                opacity: 0;
            }
            10% {
                opacity: 1; /* Fade in when starting to fall */
            }
            90% {
                opacity: 1; /* Visible for most of the duration */
            }
            100% {
                transform: translateY(110vh) translateX(0); /* Fall to bottom of screen */
                opacity: 0; /* Fade out off screen */
            }
        }
    </style>
</head>
<body>
    <div class="background-gradient" id="background-gradient"></div>
    <div class="celestial-container">
        <div class="sun" id="sun"></div>
        <div class="moon" id="moon"></div>
    </div>
    <div class="star-container" id="star-container"></div>

    <!-- Weather containers -->
    <div class="cloud-container" id="cloud-container">
        <canvas id="cloudCanvas"></canvas> <!-- Canvas for dynamic clouds -->
    </div>
    <div class="rain-container" id="rain-container"></div>

    <div class="content">
        <p class="waiting-message">しばらくお待ち下さい……</p>
    </div>

    <script>
        // グローバル変数
        let weatherTransitionStartTime = 0;
        let weatherTransitionDuration = 2000; // 2 seconds
        let weatherState = 'clear'; // 'clear', 'cloudy', 'rainy' // Track weather state
        let targetCloudOpacity = 0;
        let targetRainOpacity = 0;

        // レンダリングされた雲と雨の実際の不透明度を追跡
        let initialCloudOpacity = 0;
        let initialRainOpacity = 0;
        let lastRenderedCloudOpacity = 0;
        let lastRenderedRainOpacity = 0;

        let nextWeatherDecisionTime = 5000; // 最初の決定は5秒後
        const weatherDecisionInterval = 15000; // 15秒ごとに天候を変更

        // 天候をランダムに選択する関数
        const chooseNewWeather = () => {
            const rand = Math.random();
            if (rand < 0.6) { // 60% clear
                return 'clear';
            } else if (rand < 0.9) { // 30% cloudy
                return 'cloudy';
            } else { // 10% rainy
                return 'rainy';
            }
        };

        // DOM要素の取得
        const background = document.getElementById('background-gradient');
        const sun = document.getElementById('sun');
        const moon = document.getElementById('moon');
        const starContainer = document.getElementById('star-container');
        const cloudContainer = document.getElementById('cloud-container');
        const cloudCanvas = document.getElementById('cloudCanvas');
        const rainContainer = document.getElementById('rain-container');
        const ctx = cloudCanvas.getContext('2d');

        let animationFrameId; // For canceling animation frame on resize

        // キャンバスサイズをロード時とリサイズ時に調整
        const adjustCanvasSize = () => {
            cloudCanvas.width = cloudContainer.clientWidth;
            cloudCanvas.height = cloudContainer.clientHeight;
        };

        // 初期サイズ調整
        adjustCanvasSize();
        // リサイズリスナーの追加
        window.addEventListener('resize', adjustCanvasSize);

        const numStars = 150; // 生成する星の数
        const numShootingStars = 5; // 生成する流れ星の数
        const numRaindrops = 200; // 生成する雨粒の数

        // --- 雲の生成 (Canvas) ---
        const clouds = [];
        const numClouds = 15; // 個々の雲の数

        // 雲オブジェクトのコンストラクタ
        class Cloud {
            constructor() {
                this.width = Math.random() * 200 + 150; // 雲の幅 (150px to 350px)
                this.height = this.width * (Math.random() * 0.15 + 0.25); // 雲の高さ (width * 0.25 to 0.4)
                this.x = Math.random() * cloudCanvas.width * 1.5 - cloudCanvas.width * 0.5;
                this.y = Math.random() * cloudCanvas.height * 0.3; // 画面上部30%
                this.speed = Math.random() * 0.7 + 0.3; // 雲の速度 (0.3 to 1.0 pixels/frame)
                this.baseOpacity = Math.random() * 0.2 + 0.7; // 雲の基本不透明度 (0.7 to 0.9)

                this.blobs = [];
                const numBlobs = Math.floor(Math.random() * 5) + 6; // 雲ごとのブロブ数 (6 to 10)
                for (let i = 0; i < numBlobs; i++) {
                    const blobRadius = (Math.random() * 0.2 + 0.3) * this.height;
                    const blobX = (Math.random() - 0.5) * this.width * 0.8;
                    const blobY = (Math.random() - 0.5) * this.height * 0.8;
                    this.blobs.push({ x: blobX, y: blobY, radius: blobRadius });
                }
            }

            // 雲の位置を更新
            update() {
                this.x += this.speed;
                // 雲が画面の右端を越えたら左端にリセット
                if (this.x > cloudCanvas.width + this.width) {
                    this.x = -this.width; // 画面左端にリセット
                    this.y = Math.random() * cloudCanvas.height * 0.3; // 新しいY位置
                    // 雲が巻き戻るときに新しい形状のためにブロブを再生成
                    this.blobs = [];
                    const numBlobs = Math.floor(Math.random() * 5) + 6;
                    for (let i = 0; i < numBlobs; i++) {
                        const blobRadius = (Math.random() * 0.2 + 0.3) * this.height;
                        const blobX = (Math.random() - 0.5) * this.width * 0.8;
                        const blobY = (Math.random() - 0.5) * this.height * 0.8;
                        this.blobs.push({ x: blobX, y: blobY, radius: blobRadius });
                    }
                    this.baseOpacity = Math.random() * 0.2 + 0.7; // 新しいランダムな基本不透明度
                    this.speed = Math.random() * 0.7 + 0.3; // 新しいランダムな速度
                }
            }

            // キャンバスに雲を描画
            draw(context, overallCloudOpacity) {
                context.save();
                // 雲コンテナ全体の不透明度と雲自身の基本不透明度を適用
                context.globalAlpha = this.baseOpacity * Math.max(0.1, overallCloudOpacity); // 最低不透明度0.1

                // 柔らかいエッジのためにコンテキストにぼかしを適用
                context.filter = 'blur(15px)'; // 雲をよりふわふわにするためにぼかしを増加

                // 雲の色とグラデーションを設定
                const gradient = context.createRadialGradient(
                    this.x + this.width / 2, this.y + this.height / 2, this.height * 0.1,
                    this.x + this.width / 2, this.y + this.height / 2, this.height * 0.8
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(0.5, 'rgba(240, 240, 240, 0.8)');
                gradient.addColorStop(1, 'rgba(210, 210, 210, 0.6)');
                context.fillStyle = gradient;

                // 各ブロブを描画
                this.blobs.forEach(blob => {
                    context.beginPath();
                    context.arc(this.x + this.width / 2 + blob.x, this.y + this.height / 2 + blob.y, blob.radius, 0, Math.PI * 2);
                    context.fill();
                });

                // 奥行きのために微妙な影を追加
                context.filter = 'none'; // 影を描画するために一時的にぼかしを無効化
                context.shadowColor = 'rgba(0, 0, 0, 0.2)';
                context.shadowBlur = 30; // 影のぼかしを増加
                context.shadowOffsetX = 15; // 影のオフセットを増加
                context.shadowOffsetY = 15;

                context.restore(); // グローバルアルファ、フィルター、シャドウ設定前のコンテキストを復元
            }
        }

        // 雲の初期化
        for (let i = 0; i < numClouds; i++) {
            clouds.push(new Cloud());
        }

        // きらめく星を作成する関数
        function createStar() {
            const star = document.createElement('div');
            star.className = 'star';
            const size = Math.random() * 3 + 1; // 星のサイズ (1px to 4px)
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${Math.random() * 100}%`; // ランダムなX位置
            star.style.top = `${Math.random() * 100}%`; // ランダムなY位置
            star.style.animationDelay = `${Math.random() * 4}s`; // アニメーション開始をずらす
            starContainer.appendChild(star);
        }

        // 流れ星を作成する関数
        function createShootingStar() {
            const shootingStar = document.createElement('div');
            shootingStar.className = 'shooting-star';
            // 画面上のどこからでも出現するように位置を調整
            shootingStar.style.left = `${Math.random() * 100}%`;
            shootingStar.style.top = `${Math.random() * 100}%`;
            // アニメーション開始をずらす
            shootingStar.style.animationDelay = `${Math.random() * 8}s`;
            // 流れ星の速度をランダム化
            shootingStar.style.animationDuration = `${Math.random() * 5 + 5}s`; // 5s to 10s
            starContainer.appendChild(shootingStar);
        }

        // 個々の雨粒を作成する関数
        function createRaindrop() {
            const raindrop = document.createElement('div');
            raindrop.className = 'raindrop';
            const size = Math.random() * 2 + 1; // 雨粒の幅 (1px to 3px)
            const height = Math.random() * 10 + 5; // 雨粒の高さ (5px to 15px)
            raindrop.style.width = `${size}px`;
            raindrop.style.height = `${height}px`;
            raindrop.style.left = `${Math.random() * 100}%`; // ランダムなX位置
            raindrop.style.animationDuration = `${Math.random() * 0.8 + 0.4}s`; // 落下速度 (0.4s to 1.2s)
            raindrop.style.animationDelay = `${Math.random() * 3}s`; // アニメーション開始遅延
            rainContainer.appendChild(raindrop);
        }

        // 指定された数の星と流れ星を生成
        for (let i = 0; i < numStars; i++) {
            createStar();
        }
        for (let i = 0; i < numShootingStars; i++) {
            createShootingStar();
        }
        // 雨粒を生成
        for (let i = 0; i < numRaindrops; i++) {
            createRaindrop();
        }

        // ヘルパー関数: グラデーション文字列からRGBコンポーネントを解析
        function parseGradientColors(gradientString) {
            const cleanString = gradientString.replace(/linear-gradient\(to bottom,\s*|\)/g, '');
            const colorParts = cleanString.split(', ').map(part => part.trim());

            const hexToRgb = (hex) => {
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                return [r, g, b];
            };

            const rgbToRgb = (rgbString) => {
                const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                return match ? [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])] : [0, 0, 0];
            };

            const colors = colorParts.map(colorPart => {
                if (colorPart.startsWith('#')) {
                    return hexToRgb(colorPart);
                } else if (colorPart.startsWith('rgb')) {
                    return rgbToRgb(colorPart);
                }
                return [0, 0, 0]; // デフォルト
            });

            return { start: colors[0], end: colors[1] };
        }

        // ヘルパー関数: 2つのRGB色を補間
        function interpolateRgb(color1, color2, progress) {
            const r = Math.round(color1[0] + (color2[0] - color1[0]) * progress);
            const g = Math.round(color1[1] + (color2[1] - color1[1]) * progress);
            const b = Math.round(color1[2] + (color2[2] - color1[2]) * progress);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // 天体用の共通の弧のパスを定義
        // t: 弧に沿った進行度、0から1 (0=左の地平線、0.5=天頂、1=右の地平線)
        // y_zenith: 最も低いY値 (画面上の最高点)
        // y_horizon: 最も高いY値 (画面上の最低点、地平線近く)
        const getArcPosition = (t, y_zenith = 5, y_horizon = 30) => {
            const x = -20 + (140 * t); // x from -20% to 120%
            // 弧を作成するためにyにサイン波を使用
            // t=0 -> y=y_horizon (地平線から開始)
            // t=0.5 -> y=y_zenith (ピーク)
            // t=1 -> y=y_horizon (地平線で終了)
            const y = y_horizon + (y_zenith - y_horizon) * Math.sin(t * Math.PI);
            return { x, y };
        };

        // サイクル全体の背景色のキーフレームを定義
        // これらのポイントは、特定のglobalProgress値 (0から1) での空の色を定義
        const bgKeyframes = [
            { progress: 0.0, colors: parseGradientColors("linear-gradient(to bottom, #000000, #0a0a20)") }, // 真夜中 (開始)
            { progress: 0.1, colors: parseGradientColors("linear-gradient(to bottom, #2c0b40, #5c2070)") }, // 早朝の夜明け (深い紫)
            { progress: 0.2, colors: parseGradientColors("linear-gradient(to bottom, #FFC0CB, #87CEEB)") }, // 日の出 (淡いピンク/青)
            { progress: 0.35, colors: parseGradientColors("linear-gradient(to bottom, #87CEEB, #ADD8E6)") }, // 朝/日中
            { progress: 0.5, colors: parseGradientColors("linear-gradient(to bottom, #87CEEB, #ADD8E6)") }, // 日中 (朝と同じで平坦化)
            { progress: 0.65, colors: parseGradientColors("linear-gradient(to bottom, #FFD700, #FFA500)") }, // 午後遅く/日没開始 (暖かい色)
            { progress: 0.75, colors: parseGradientColors("linear-gradient(to bottom, #FF8C00, #4682B4)") }, // 日没/夕暮れ (オレンジからスチールブルー)
            { progress: 0.9, colors: parseGradientColors("linear-gradient(to bottom, #0A0A20, #000005)") }, // 早い夜 (暗くなる)
            { progress: 1.0, colors: parseGradientColors("linear-gradient(to bottom, #000000, #0a0a20)") }  // サイクルの終わり (真夜中と同じ)
        ];

        const totalCycleDuration = 60000; // 昼夜サイクルの合計期間 (ミリ秒) (60秒)
        let startTime = null;

        // メインアニメーションループ
        const animateCycle = (currentTime) => {
            if (!startTime) startTime = currentTime;
            const elapsedTime = currentTime - startTime;
            const globalProgress = (elapsedTime % totalCycleDuration) / totalCycleDuration; // 0から1、継続的にループ

            // --- 太陽と月の位置と不透明度 ---
            const sunArcStartGlobal = 0.15; // 太陽が弧を開始するグローバル進行度 (早朝)
            const sunArcEndGlobal = 0.85;   // 太陽が弧を終えるグローバル進行度 (夜遅く)
            const moonArcStartGlobal = 0.65; // 月が弧を開始するグローバル進行度 (夕暮れ)
            const moonArcEndGlobal = 0.25;   // 月が弧を終えるグローバル進行度 (翌朝)

            // 太陽の位置と不透明度を計算
            let sunArcProgress = 0; // 太陽の弧に沿った進行度 (0から1)
            let sunOpacity = 0;
            if (globalProgress >= sunArcStartGlobal && globalProgress <= sunArcEndGlobal) {
                sunArcProgress = (globalProgress - sunArcStartGlobal) / (sunArcEndGlobal - sunArcStartGlobal);
                
                const fadeDurationRatio = 0.15; // 弧のどれくらいの期間をフェードイン/アウトに費やすか
                if (sunArcProgress < fadeDurationRatio) {
                    sunOpacity = sunArcProgress / fadeDurationRatio; // フェードイン
                } else if (sunArcProgress > (1 - fadeDurationRatio)) {
                    sunOpacity = (1 - sunArcProgress) / fadeDurationRatio; // フェードアウト
                } else {
                    sunOpacity = 1; // 完全に表示
                }
            }
            const sunPos = getArcPosition(sunArcProgress);
            sun.style.left = `${sunPos.x}%`;
            sun.style.top = `${sunPos.y}%`;
            sun.style.opacity = Math.max(0, Math.min(1, sunOpacity)); // 不透明度をクランプ

            // 月の位置と不透明度を計算
            let moonArcProgress = 0; // 月の弧に沿った進行度 (0から1)
            let moonOpacity = 0;
            if (globalProgress >= moonArcStartGlobal || globalProgress < moonArcEndGlobal) {
                if (globalProgress >= moonArcStartGlobal) {
                    moonArcProgress = (globalProgress - moonArcStartGlobal) / (1.0 - moonArcStartGlobal + moonArcEndGlobal);
                } else { // globalProgress < moonArcEndGlobal
                    moonArcProgress = (globalProgress + (1.0 - moonArcStartGlobal)) / (1.0 - moonArcStartGlobal + moonArcEndGlobal);
                }
                
                const fadeDurationRatio = 0.15; // 弧のどれくらいの期間をフェードイン/アウトに費やすか
                if (moonArcProgress < fadeDurationRatio) {
                    moonOpacity = moonArcProgress / fadeDurationRatio; // フェードイン
                } else if (moonArcProgress > (1 - fadeDurationRatio)) {
                    moonOpacity = (1 - moonArcProgress) / fadeDurationRatio; // フェードアウト
                } else {
                    moonOpacity = 1; // 完全に表示
                }
            }
            const moonPos = getArcPosition(moonArcProgress);
            moon.style.left = `${moonPos.x}%`;
            moon.style.top = `${moonPos.y}%`;
            moon.style.opacity = Math.max(0, Math.min(1, moonOpacity)); // 不透明度をクランプ

            // --- 星の不透明度 ---
            let currentStarsBaseOpacity;
            const starFadeInStart = 0.75; // 夕暮れ後、星がフェードインを開始
            const starFullVisibleStart = 0.85; // 完全に星が見える開始点
            const starFullVisibleEnd = 0.15; // 完全に星が見える終了点 (ラップアラウンド)
            const starFadeOutEnd = 0.25; // 星がフェードアウトを終了する点 (朝)

            if (globalProgress >= starFadeInStart || globalProgress < starFadeOutEnd) {
                if (globalProgress >= starFadeInStart) { // フェードイン段階 (夕暮れから真夜中へ)
                    if (globalProgress < starFullVisibleStart) {
                        currentStarsBaseOpacity = (globalProgress - starFadeInStart) / (starFullVisibleStart - starFadeInStart);
                    } else { // >= starFullVisibleStart (真夜中方向へ)
                        currentStarsBaseOpacity = 1;
                    }
                } else { // globalProgress < starFadeOutEnd (真夜中から朝へ)
                    if (globalProgress < starFullVisibleEnd) { // 完全に表示される段階 (真夜中後)
                        currentStarsBaseOpacity = 1;
                    } else { // >= starFullVisibleEnd (朝方向へフェードアウト)
                        currentStarsBaseOpacity = 1 - (globalProgress - starFullVisibleEnd) / (starFadeOutEnd - starFullVisibleEnd);
                    }
                }
            } else {
                currentStarsBaseOpacity = 0; // 日中
            }
            currentStarsBaseOpacity = Math.max(0, Math.min(1, currentStarsBaseOpacity)); // クランプ

            // --- 背景グラデーション ---
            let currentBgKeyframe = 0;
            for (let i = 0; i < bgKeyframes.length - 1; i++) {
                if (globalProgress >= bgKeyframes[i].progress && globalProgress <= bgKeyframes[i + 1].progress) {
                    currentBgKeyframe = i;
                    break;
                }
                // 最後のキーフレームから最初のキーフレームへのラップアラウンドを処理 (例: globalProgress = 0.95, 次は0.0)
                if (i === bgKeyframes.length - 2 && globalProgress > bgKeyframes[i + 1].progress) {
                    currentBgKeyframe = i + 1;
                }
            }

            const startBgKey = bgKeyframes[currentBgKeyframe];
            const endBgKey = bgKeyframes[(currentBgKeyframe + 1) % bgKeyframes.length];

            let bgProgressInSegment;
            if (endBgKey.progress < startBgKey.progress) { // ラップアラウンドの場合 (例: 0.9から0.0)
                bgProgressInSegment = (globalProgress - startBgKey.progress + 1) % 1 / (1 - startBgKey.progress + endBgKey.progress);
            } else {
                bgProgressInSegment = (globalProgress - startBgKey.progress) / (endBgKey.progress - startBgKey.progress);
            }
            bgProgressInSegment = Math.max(0, Math.min(1, bgProgressInSegment)); // 0から1の間にクランプ

            const interpolatedStartColor = interpolateRgb(startBgKey.colors.start, endBgKey.colors.start, bgProgressInSegment);
            const interpolatedEndColor = interpolateRgb(startBgKey.colors.end, endBgKey.colors.end, bgProgressInSegment);
            background.style.backgroundImage = `linear-gradient(to bottom, ${interpolatedStartColor}, ${interpolatedEndColor})`;

            // --- 天候決定ロジック ---
            if (currentTime >= nextWeatherDecisionTime) {
                nextWeatherDecisionTime += weatherDecisionInterval;
                const newWeather = chooseNewWeather();

                if (newWeather !== weatherState) {
                    weatherState = newWeather;
                    weatherTransitionStartTime = currentTime; // 天候変更の時間を記録
                    // スムーズな遷移開始のために、最後にレンダリングされた不透明度をキャプチャ
                    initialCloudOpacity = lastRenderedCloudOpacity;
                    initialRainOpacity = lastRenderedRainOpacity;

                    if (weatherState === 'cloudy') {
                        targetCloudOpacity = 1;
                        targetRainOpacity = 0;
                    } else if (weatherState === 'rainy') {
                        targetCloudOpacity = 1; // 雨には常に雲
                        targetRainOpacity = 1;
                    } else { // 'clear'
                        // 晴天時のtargetCloudOpacityを高く設定し、視認性を確保するように変更
                        targetCloudOpacity = 0.5; // 雲の密度を薄くするが、はっきりと見えるようにする
                        targetRainOpacity = 0;
                    }
                }
            }
            
            // --- 天候遷移アニメーション ---
            const transitionProgress = Math.min(1, (currentTime - weatherTransitionStartTime) / weatherTransitionDuration);

            const currentCloudOpacity = initialCloudOpacity + (targetCloudOpacity - initialCloudOpacity) * transitionProgress;
            const currentRainOpacity = initialRainOpacity + (targetRainOpacity - initialRainOpacity) * transitionProgress;

            // 次のフレーム/遷移のために最後にレンダリングされた不透明度を更新
            lastRenderedCloudOpacity = currentCloudOpacity;
            lastRenderedRainOpacity = currentRainOpacity;

            // 雲を描画するためにキャンバスをクリア
            ctx.clearRect(0, 0, cloudCanvas.width, cloudCanvas.height);
            // 雲を更新して描画
            clouds.forEach(cloud => {
                cloud.update();
                cloud.draw(ctx, currentCloudOpacity); // ブレンドのためにcurrentCloudOpacityを渡す
            });

            // rainContainerは引き続きstyle.opacityを使用しているため、問題ないはず
            rainContainer.style.opacity = `${currentRainOpacity}`;

            // 天候に基づいて星の不透明度を調整 (天候要素が見える場合は星がフェードアウト)
            // 雲越しでも星は見えるが、不透明度は減少する
            const cloudImpactFactor = 0.7; // 雲や雨の際の星の透明度の減少量 (0.7は元の透明度の30%が見えることを意味する)
            const weatherCoverOpacity = Math.max(currentCloudOpacity, currentRainOpacity); // 雲または雨の最大不透明度
            starContainer.style.opacity = Math.max(0, Math.min(1, currentStarsBaseOpacity * (1 - weatherCoverOpacity * (1 - cloudImpactFactor))));

            animationFrameId = requestAnimationFrame(animateCycle);
        };

        // window.onloadでアニメーションループを開始
        window.onload = function () {
            // アニメーションをウィンドウロード時に開始
            animationFrameId = requestAnimationFrame(animateCycle);
        }
    </script>
</body>
</html>
